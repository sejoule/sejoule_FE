import { ChangeDetectionStrategy, Component, EventEmitter, HostBinding, Input, KeyValueDiffers, NgZone, Optional, Output, Self, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';
import { NgControl } from '@angular/forms';
import { MatFormFieldControl } from '@angular/material';
import { Subject } from 'rxjs/Subject';
import { coerceBooleanProperty } from '@angular/cdk/coercion';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MatCodemirrorComponent {
    /**
     * @param {?} ngControl
     * @param {?} _differs
     * @param {?} _ngZone
     */
    constructor(ngControl, _differs, _ngZone) {
        this.ngControl = ngControl;
        this._differs = _differs;
        this._ngZone = _ngZone;
        this.stateChanges = new Subject();
        this.id = `mat-codemirror-component-${MatCodemirrorComponent.materialId++}`;
        this.describedBy = '';
        this.onChange = (_) => null;
        this.onTouched = () => null;
        this._required = false;
        this._focused = false;
        this._disabled = false;
        this._value = '';
        this.ngxMatCodemirror = true;
        /* class applied to the created textarea */
        this.className = '';
        /* name applied to the created textarea */
        this.name = 'codemirror';
        /* autofocus setting applied to the created textarea */
        this.autoFocus = false;
        /* preserve previous scroll position after updating value */
        this.preserveScrollPosition = false;
        /* called when the text cursor is moved */
        this.cursorActivity = new EventEmitter();
        /* called when the editor is focused or loses focus */
        this.focusChange = new EventEmitter();
        /* called when the editor is scrolled */
        this.scroll = new EventEmitter();
        if (this.ngControl != null) {
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * @return {?}
     */
    get shouldLabelFloat() {
        return this.focused || !this.empty;
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    setDescribedByIds(ids) {
        this.describedBy = ids.join(' ');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onContainerClick(event) { }
    /**
     * @return {?}
     */
    get required() {
        return this._required;
    }
    /**
     * @param {?} req
     * @return {?}
     */
    set required(req) {
        this._required = coerceBooleanProperty(req);
        this.stateChanges.next();
    }
    /**
     * @return {?}
     */
    get errorState() {
        return this.ngControl && !this.ngControl.pristine && !this.ngControl.valid;
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @param {?} plh
     * @return {?}
     */
    set placeholder(plh) {
        this._placeholder = plh;
        this.stateChanges.next();
    }
    /**
     * @return {?}
     */
    get empty() {
        return !this.value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value;
        this.updateLineNumbers();
        this.stateChanges.next();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} dis
     * @return {?}
     */
    set disabled(dis) {
        this._disabled = coerceBooleanProperty(dis);
        this.stateChanges.next();
    }
    /**
     * @return {?}
     */
    get focused() {
        return this._focused;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set focused(val) {
        this._focused = val;
        this.stateChanges.next();
    }
    /**
     * set options for codemirror
     * @link http://codemirror.net/doc/manual.html#config
     * @param {?} value
     * @return {?}
     */
    set options(value) {
        this._options = value;
        if (!this._differ && value) {
            this._differ = this._differs.find(value).create();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.ref) {
            return;
        }
        // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors
        const { fromTextArea } = require('codemirror');
        this.codeMirror = fromTextArea(this.ref.nativeElement, this._options);
        this.updateLineNumbers();
        this._ngZone.runOutsideAngular(() => {
            this.codeMirror.on('change', this.codemirrorValueChanged.bind(this));
            this.codeMirror.on('cursorActivity', this.cursorActive.bind(this));
            this.codeMirror.on('focus', this.focusChanged.bind(this, true));
            this.codeMirror.on('blur', this.focusChanged.bind(this, false));
            this.codeMirror.on('scroll', this.scrollChanged.bind(this));
        });
        this.codeMirror.setValue(this.value);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._differ) {
            // check options have not changed
            const /** @type {?} */ changes = this._differ.diff(this._options);
            if (changes) {
                changes.forEachChangedItem(option => this.setOptionIfChanged(option.key, option.currentValue));
                changes.forEachAddedItem(option => this.setOptionIfChanged(option.key, option.currentValue));
                changes.forEachRemovedItem(option => this.setOptionIfChanged(option.key, option.currentValue));
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // is there a lighter-weight way to remove the cm instance?
        if (this.codeMirror) {
            this.codeMirror.toTextArea();
        }
        this.stateChanges.complete();
    }
    /**
     * @param {?} cm
     * @param {?} change
     * @return {?}
     */
    codemirrorValueChanged(cm, change) {
        if (change.origin !== 'setValue') {
            this.value = cm.getValue();
            this.writeValue(cm.getValue());
        }
    }
    /**
     * @param {?} optionName
     * @param {?} newValue
     * @return {?}
     */
    setOptionIfChanged(optionName, newValue) {
        if (!this.codeMirror) {
            return;
        }
        this.codeMirror.setOption(optionName, newValue);
    }
    /**
     * @param {?} focused
     * @return {?}
     */
    focusChanged(focused) {
        this.onTouched();
        this.focused = focused;
        this.focusChange.emit(focused);
    }
    /**
     * @param {?} cm
     * @return {?}
     */
    scrollChanged(cm) {
        this.scroll.emit(cm.getScrollInfo());
    }
    /**
     * @param {?} cm
     * @return {?}
     */
    cursorActive(cm) {
        this.cursorActivity.emit(cm);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value === null) {
            return;
        }
        if (value && !this.codeMirror) {
            this.value = value;
            return;
        }
        if (value &&
            value !== this.codeMirror.getValue() &&
            this.normalizeLineEndings(this.codeMirror.getValue()) !==
                this.normalizeLineEndings(value)) {
            this.value = value;
            if (this.preserveScrollPosition) {
                const /** @type {?} */ prevScrollPosition = this.codeMirror.getScrollInfo();
                this.codeMirror.setValue(this.value);
                this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
                return;
            }
            this.codeMirror.setValue(this.value);
            // Don't call onChange value is from ngModel
            return;
        }
        this.onChange(this.value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.setOptionIfChanged('readOnly', this.disabled);
    }
    /**
     * @param {?} str
     * @return {?}
     */
    normalizeLineEndings(str) {
        return (str || '').replace(/\r\n|\r/g, '\n');
    }
    /**
     * @return {?}
     */
    updateLineNumbers() {
        if (this.codeMirror) {
            this.codeMirror.setOption('lineNumbers', !!/\n/.test(this._value));
        }
    }
}
MatCodemirrorComponent.materialId = 0;
MatCodemirrorComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-codemirror',
                template: `<textarea
  [name]="name"
  class="ngx-codemirror {{ className }}"
  [class.ngx-codemirror--focused]="focused"
  autocomplete="off"
  [autofocus]="autoFocus"
  #ref>
</textarea>
`,
                styles: [`.ngx-mat-codemirror .CodeMirror{height:auto}.ngx-mat-codemirror .CodeMirror-scroll{max-height:250px}`],
                providers: [
                    {
                        provide: MatFormFieldControl,
                        useExisting: MatCodemirrorComponent
                    }
                ],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
MatCodemirrorComponent.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self },] },
    { type: KeyValueDiffers, },
    { type: NgZone, },
];
MatCodemirrorComponent.propDecorators = {
    "id": [{ type: HostBinding },],
    "describedBy": [{ type: HostBinding, args: ['attr.aria-describedby',] },],
    "ngxMatCodemirror": [{ type: HostBinding, args: ['class.ngx-mat-codemirror',] },],
    "className": [{ type: Input },],
    "name": [{ type: Input },],
    "autoFocus": [{ type: Input },],
    "preserveScrollPosition": [{ type: Input },],
    "cursorActivity": [{ type: Output },],
    "focusChange": [{ type: Output },],
    "scroll": [{ type: Output },],
    "ref": [{ type: ViewChild, args: ['ref',] },],
    "shouldLabelFloat": [{ type: HostBinding, args: ['class.floating',] },],
    "required": [{ type: Input },],
    "placeholder": [{ type: Input },],
    "disabled": [{ type: Input },],
    "options": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MatCodemirrorModule {
}
MatCodemirrorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    MatCodemirrorComponent,
                ],
                exports: [
                    MatCodemirrorComponent,
                ]
            },] },
];
/** @nocollapse */
MatCodemirrorModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { MatCodemirrorModule, MatCodemirrorComponent as ɵa };
//# sourceMappingURL=ngx-mat-codemirror.js.map
