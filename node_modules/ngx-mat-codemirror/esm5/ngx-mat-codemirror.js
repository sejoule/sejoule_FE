import { ChangeDetectionStrategy, Component, EventEmitter, HostBinding, Input, KeyValueDiffers, NgZone, Optional, Output, Self, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';
import { NgControl } from '@angular/forms';
import { MatFormFieldControl } from '@angular/material';
import { Subject } from 'rxjs/Subject';
import { coerceBooleanProperty } from '@angular/cdk/coercion';

var MatCodemirrorComponent = /** @class */ (function () {
    function MatCodemirrorComponent(ngControl, _differs, _ngZone) {
        this.ngControl = ngControl;
        this._differs = _differs;
        this._ngZone = _ngZone;
        this.stateChanges = new Subject();
        this.id = "mat-codemirror-component-" + MatCodemirrorComponent.materialId++;
        this.describedBy = '';
        this.onChange = function (_) { return null; };
        this.onTouched = function () { return null; };
        this._required = false;
        this._focused = false;
        this._disabled = false;
        this._value = '';
        this.ngxMatCodemirror = true;
        this.className = '';
        this.name = 'codemirror';
        this.autoFocus = false;
        this.preserveScrollPosition = false;
        this.cursorActivity = new EventEmitter();
        this.focusChange = new EventEmitter();
        this.scroll = new EventEmitter();
        if (this.ngControl != null) {
            this.ngControl.valueAccessor = this;
        }
    }
    Object.defineProperty(MatCodemirrorComponent.prototype, "shouldLabelFloat", {
        get: function () {
            return this.focused || !this.empty;
        },
        enumerable: true,
        configurable: true
    });
    MatCodemirrorComponent.prototype.setDescribedByIds = function (ids) {
        this.describedBy = ids.join(' ');
    };
    MatCodemirrorComponent.prototype.onContainerClick = function (event) { };
    Object.defineProperty(MatCodemirrorComponent.prototype, "required", {
        get: function () {
            return this._required;
        },
        set: function (req) {
            this._required = coerceBooleanProperty(req);
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCodemirrorComponent.prototype, "errorState", {
        get: function () {
            return this.ngControl && !this.ngControl.pristine && !this.ngControl.valid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCodemirrorComponent.prototype, "placeholder", {
        get: function () {
            return this._placeholder;
        },
        set: function (plh) {
            this._placeholder = plh;
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCodemirrorComponent.prototype, "empty", {
        get: function () {
            return !this.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCodemirrorComponent.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (value) {
            this._value = value;
            this.updateLineNumbers();
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCodemirrorComponent.prototype, "disabled", {
        get: function () {
            return this._disabled;
        },
        set: function (dis) {
            this._disabled = coerceBooleanProperty(dis);
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCodemirrorComponent.prototype, "focused", {
        get: function () {
            return this._focused;
        },
        set: function (val) {
            this._focused = val;
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatCodemirrorComponent.prototype, "options", {
        set: function (value) {
            this._options = value;
            if (!this._differ && value) {
                this._differ = this._differs.find(value).create();
            }
        },
        enumerable: true,
        configurable: true
    });
    MatCodemirrorComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!this.ref) {
            return;
        }
        var fromTextArea = require('codemirror').fromTextArea;
        this.codeMirror = fromTextArea(this.ref.nativeElement, this._options);
        this.updateLineNumbers();
        this._ngZone.runOutsideAngular(function () {
            _this.codeMirror.on('change', _this.codemirrorValueChanged.bind(_this));
            _this.codeMirror.on('cursorActivity', _this.cursorActive.bind(_this));
            _this.codeMirror.on('focus', _this.focusChanged.bind(_this, true));
            _this.codeMirror.on('blur', _this.focusChanged.bind(_this, false));
            _this.codeMirror.on('scroll', _this.scrollChanged.bind(_this));
        });
        this.codeMirror.setValue(this.value);
    };
    MatCodemirrorComponent.prototype.ngDoCheck = function () {
        var _this = this;
        if (this._differ) {
            var changes = this._differ.diff(this._options);
            if (changes) {
                changes.forEachChangedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
                changes.forEachAddedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
                changes.forEachRemovedItem(function (option) { return _this.setOptionIfChanged(option.key, option.currentValue); });
            }
        }
    };
    MatCodemirrorComponent.prototype.ngOnDestroy = function () {
        if (this.codeMirror) {
            this.codeMirror.toTextArea();
        }
        this.stateChanges.complete();
    };
    MatCodemirrorComponent.prototype.codemirrorValueChanged = function (cm, change) {
        if (change.origin !== 'setValue') {
            this.value = cm.getValue();
            this.writeValue(cm.getValue());
        }
    };
    MatCodemirrorComponent.prototype.setOptionIfChanged = function (optionName, newValue) {
        if (!this.codeMirror) {
            return;
        }
        this.codeMirror.setOption(optionName, newValue);
    };
    MatCodemirrorComponent.prototype.focusChanged = function (focused) {
        this.onTouched();
        this.focused = focused;
        this.focusChange.emit(focused);
    };
    MatCodemirrorComponent.prototype.scrollChanged = function (cm) {
        this.scroll.emit(cm.getScrollInfo());
    };
    MatCodemirrorComponent.prototype.cursorActive = function (cm) {
        this.cursorActivity.emit(cm);
    };
    MatCodemirrorComponent.prototype.writeValue = function (value) {
        if (value === null) {
            return;
        }
        if (value && !this.codeMirror) {
            this.value = value;
            return;
        }
        if (value &&
            value !== this.codeMirror.getValue() &&
            this.normalizeLineEndings(this.codeMirror.getValue()) !==
                this.normalizeLineEndings(value)) {
            this.value = value;
            if (this.preserveScrollPosition) {
                var prevScrollPosition = this.codeMirror.getScrollInfo();
                this.codeMirror.setValue(this.value);
                this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
                return;
            }
            this.codeMirror.setValue(this.value);
            return;
        }
        this.onChange(this.value);
    };
    MatCodemirrorComponent.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MatCodemirrorComponent.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    MatCodemirrorComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        this.setOptionIfChanged('readOnly', this.disabled);
    };
    MatCodemirrorComponent.prototype.normalizeLineEndings = function (str) {
        return (str || '').replace(/\r\n|\r/g, '\n');
    };
    MatCodemirrorComponent.prototype.updateLineNumbers = function () {
        if (this.codeMirror) {
            this.codeMirror.setOption('lineNumbers', !!/\n/.test(this._value));
        }
    };
    return MatCodemirrorComponent;
}());
MatCodemirrorComponent.materialId = 0;
MatCodemirrorComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-codemirror',
                template: "<textarea\n  [name]=\"name\"\n  class=\"ngx-codemirror {{ className }}\"\n  [class.ngx-codemirror--focused]=\"focused\"\n  autocomplete=\"off\"\n  [autofocus]=\"autoFocus\"\n  #ref>\n</textarea>\n",
                styles: [".ngx-mat-codemirror .CodeMirror{height:auto}.ngx-mat-codemirror .CodeMirror-scroll{max-height:250px}"],
                providers: [
                    {
                        provide: MatFormFieldControl,
                        useExisting: MatCodemirrorComponent
                    }
                ],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
            },] },
];
MatCodemirrorComponent.ctorParameters = function () { return [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self },] },
    { type: KeyValueDiffers, },
    { type: NgZone, },
]; };
MatCodemirrorComponent.propDecorators = {
    "id": [{ type: HostBinding },],
    "describedBy": [{ type: HostBinding, args: ['attr.aria-describedby',] },],
    "ngxMatCodemirror": [{ type: HostBinding, args: ['class.ngx-mat-codemirror',] },],
    "className": [{ type: Input },],
    "name": [{ type: Input },],
    "autoFocus": [{ type: Input },],
    "preserveScrollPosition": [{ type: Input },],
    "cursorActivity": [{ type: Output },],
    "focusChange": [{ type: Output },],
    "scroll": [{ type: Output },],
    "ref": [{ type: ViewChild, args: ['ref',] },],
    "shouldLabelFloat": [{ type: HostBinding, args: ['class.floating',] },],
    "required": [{ type: Input },],
    "placeholder": [{ type: Input },],
    "disabled": [{ type: Input },],
    "options": [{ type: Input },],
};
var MatCodemirrorModule = /** @class */ (function () {
    function MatCodemirrorModule() {
    }
    return MatCodemirrorModule;
}());
MatCodemirrorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    MatCodemirrorComponent,
                ],
                exports: [
                    MatCodemirrorComponent,
                ]
            },] },
];
MatCodemirrorModule.ctorParameters = function () { return []; };

export { MatCodemirrorModule, MatCodemirrorComponent as ɵa };
//# sourceMappingURL=ngx-mat-codemirror.js.map
